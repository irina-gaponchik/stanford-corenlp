/* The following code was generated by JFlex 1.4.3 on 3/20/13 5:04 PM */

package edu.stanford.nlp.process;

import java.nio.CharBuffer;
import java.util.Collections;
import java.util.Set;
import java.util.logging.Logger;

import edu.stanford.nlp.process.data.*;
import edu.stanford.nlp.util.Generics;
import javolution.text.Txt;
import javolution.text.TxtBuilder;


/**
 * This class is a scanner generated by
 * <a href="http://www.jflex.de/">JFlex</a> 1.4.3 on 3/20/13 5:04 PM from the
 * specification file
 * <tt>/juicy/u61/u/horatio/codebase2/javanlp/projects/core/src/edu/stanford/nlp/process/Morpha.flex</tt>
 */
public class Morpha {

    /**
     * ZZ_ATTRIBUTE[aState] contains the attributes of state
     * <code>aState</code>
     */
    private static final int[] ZZ_ATTRIBUTE;

    static {
        int[] result = new int[13383];
        int offset = 0;
        int i = 0;       /* index in packed string  */

        int j = offset;  /* index in unpacked array */

        int l = ZZ21.ZZ_ATTRIBUTE_PACKED_0.length();
        while (i < l) {
            int count = ZZ21.ZZ_ATTRIBUTE_PACKED_0.charAt(i++);
            int value = ZZ21.ZZ_ATTRIBUTE_PACKED_0.charAt(i++);
            do result[j++] = value; while (--count > 0);
        }
        ZZ_ATTRIBUTE = result;
    }

    /**
     * This character denotes the end of file
     */
    private static final int YYEOF = -1;

    /**
     * initial size of the lookahead buffer
     */
    private static final int ZZ_BUFFERSIZE = 16384;

    /**
     * lexical states
     */
    public static final int scan = 8;
    private static final int YYINITIAL = 0;
    public static final int any = 6;
    private static final int noun = 4;
    private static final int verb = 2;

    /**
     * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
     * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l at the
     * beginning of a line l is of the form l = 2*k, k a non negative integer
     */
    private static final int ZZ_LEXSTATE[] = {
        0, 0, 1, 1, 2, 2, 3, 3, 4, 4
    };

    /**
     * Translates characters to character classes
     */
    private static final CharSequence ZZ_CMAP_PACKED =
            "\11\0\1\35\1\35\3\35\22\0\1\35\3\0\1\41\2\0\1\37"
            + "\3\0\1\1\1\0\1\34\1\40\1\0\12\1\7\0\1\43\1\5"
            + "\1\6\1\42\1\30\1\10\1\11\1\12\1\31\1\13\1\14\1\15"
            + "\1\16\1\17\1\32\1\44\1\21\1\22\1\23\1\24\1\2\1\25"
            + "\1\26\1\27\1\3\1\4\4\0\1\33\1\0\1\36\1\5\1\6"
            + "\1\7\1\30\1\10\1\11\1\12\1\31\1\13\1\14\1\15\1\16"
            + "\1\17\1\32\1\20\1\21\1\22\1\23\1\24\1\2\1\25\1\26"
            + "\1\27\1\3\1\4\12\0\1\35\u1fa2\0\2\35\udfd6\0";

    /**
     * Translates characters to character classes
     */
    private static final char[] ZZ_CMAP = zzUnpackCMap();

    /**
     * Translates DFA states to action switch labels.
     */
    private static final int[] ZZ_ACTION;

    static {
        int[] result = new int[13383];
        int i = 0;       /* index in packed string  */

        int j = 0;  /* index in unpacked array */

        int l = ZZ0.ZZ_ACTION_PACKED_0.length();
        while (i < l) {
            int count = ZZ0.ZZ_ACTION_PACKED_0.charAt(i++);
            int value = ZZ0.ZZ_ACTION_PACKED_0.charAt(i++);
            do {
                result[j++] = value;
            } while (--count > 0);
        }
        ZZ_ACTION = result;
    }

    /**
     * Translates a state to a row index in the transition table
     */
    private static final int[] ZZ_ROWMAP;

    static {
        int[] result = new int[13383];
        int offset = 0;
        int i = 0;  /* index in packed string  */

        int j = offset;  /* index in unpacked array */

        int l = ZZ0.ZZ_ROWMAP_PACKED_0.length();
        while (i < l) {
            int high = (int) ZZ0.ZZ_ROWMAP_PACKED_0.charAt(i++) << 16;
            result[j++] = high | (int) ZZ0.ZZ_ROWMAP_PACKED_0.charAt(i++);
        }

        ZZ_ROWMAP = result;
    }

    /**
     * The transition table of the DFA
     */
    private static final int[] ZZ_TRANS;

    static {
        int[] result = new int[455729];
        int offset = 0;
        offset = zzUnpackTrans(ZZ1.ZZ_TRANS_PACKED_0, offset, result);
        offset = zzUnpackTrans(ZZ1.ZZ_TRANS_PACKED_1, offset, result);
        offset = zzUnpackTrans(ZZ2.ZZ_TRANS_PACKED_2, offset, result);
        offset = zzUnpackTrans(ZZ3.ZZ_TRANS_PACKED_3, offset, result);
        offset = zzUnpackTrans(ZZ4.ZZ_TRANS_PACKED_4, offset, result);
        offset = zzUnpackTrans(ZZ5.ZZ_TRANS_PACKED_5, offset, result);
        offset = zzUnpackTrans(ZZ6.ZZ_TRANS_PACKED_6, offset, result);
        offset = zzUnpackTrans(ZZ7.ZZ_TRANS_PACKED_7, offset, result);
        offset = zzUnpackTrans(ZZ8.ZZ_TRANS_PACKED_8, offset, result);
        offset = zzUnpackTrans(ZZ9.ZZ_TRANS_PACKED_9, offset, result);
        offset = zzUnpackTrans(ZZ10.ZZ_TRANS_PACKED_10, offset, result);
        offset = zzUnpackTrans(ZZ11.ZZ_TRANS_PACKED_11, offset, result);
        offset = zzUnpackTrans(ZZ12.ZZ_TRANS_PACKED_12, offset, result);
        offset = zzUnpackTrans(ZZ13.ZZ_TRANS_PACKED_13, offset, result);
        offset = zzUnpackTrans(ZZ14.ZZ_TRANS_PACKED_14, offset, result);
        offset = zzUnpackTrans(ZZ15.ZZ_TRANS_PACKED_15, offset, result);
        offset = zzUnpackTrans(ZZ16.ZZ_TRANS_PACKED_16, offset, result);
        offset = zzUnpackTrans(ZZ17.ZZ_TRANS_PACKED_17, offset, result);
        offset = zzUnpackTrans(ZZ18.ZZ_TRANS_PACKED_18, offset, result);
        offset = zzUnpackTrans(ZZ19.ZZ_TRANS_PACKED_19, offset, result);
        offset = zzUnpackTrans(ZZ20.ZZ_TRANS_PACKED_20, offset, result);
        offset = zzUnpackTrans(ZZ21.ZZ_TRANS_PACKED_21, offset, result);
        ZZ_TRANS = result;
    }

    private static int zzUnpackTrans(CharSequence packed, int offset, int... result) {
        int i = 0;       /* index in packed string  */

        int j = offset;  /* index in unpacked array */

        int l = packed.length();
        while (i < l) {
            int count = packed.charAt(i++);
            int value = packed.charAt(i++);
            value--;
            do result[j++] = value; while (--count > 0);
        }
        return j;
    }


    /* error codes */
    private static final int ZZ_UNKNOWN_ERROR = 0;
    private static final int ZZ_NO_MATCH = 1;
    private static final int ZZ_PUSHBACK_2BIG = 2;

    /* error messages for the codes above */
    private static final CharSequence ZZ_ERROR_MSG[] = {
        "Unkown internal scanner error",
        "Error: could not match input",
        "Error: pushback value was too large"
    };

    /**
     * the input device
     */
    private java.io.Reader zzReader;

    /**
     * the current lexical state
     */
    private int zzLexicalState = YYINITIAL;

    /**
     * this buffer contains the current text to be matched and is the source of
     * the yytext() string
     */
    private char zzBuffer[] = new char[ZZ_BUFFERSIZE];

    /**
     * the textposition at the last accepting state
     */
    private int zzMarkedPos;

    /**
     * the current text position in the buffer
     */
    private int zzCurrentPos;

    /**
     * startRead marks the beginning of the yytext() string in the buffer
     */
    private int zzStartRead;

    /**
     * endRead marks the last character in the buffer, that has been read from
     * input
     */
    private int zzEndRead;

    /**
     * zzAtEOF == true <=> the scanner is at the EOF
     */
    private boolean zzAtEOF;

    /**
     * For the backwards DFA of general lookahead statements
     */
    private boolean[] zzFin = new boolean[ZZ_BUFFERSIZE + 1];

    /* user code: */    private static final Logger LOGGER = Logger.getLogger(Morphology.class.getName());

    /**
     * If this option is set, print the word affix after a + character
     */
    private final static int print_affixes = 0;
    /**
     * If this option is set, lowercase all tokens
     */
    private final static int change_case = 1;
    /**
     * Return the tags on the input words if present??
     */
    private final static int tag_output = 2;

    //accessors for the options maintained as booleans
    private final boolean[] options;
    private static final int NUM_OPTIONS = 3;

    void setOption(int i, boolean b) {
        options[i] = b;
    }

    boolean option(int i) {
        return (options[i]);
    }

    void setOptions(int opts) {
        for (int i = 0; i < NUM_OPTIONS; i++) {
            setOption(i, (opts & (1 << i)) != 0);
        }
    }

    private final static boolean noTags = false;

   
    private final Set<CharSequence> verbStemSet;

    CharSequence ynull_stem() {
        return common_noun_stem();
    }

    private CharSequence common_noun_stem() {
        return changeCase() ? yytext().toLowerCase() : yytext();
    }

    private CharSequence proper_name_stem() {
        return yytext();
    }

    /**
     * Capitalizes the first letter and lower-cases every consecutive letter.
     */
    private static CharSequence capitalise(CharSequence s) {
        if (s.length() == 0) {
            return s;
        }

        TxtBuilder s1 = new TxtBuilder(s);
        if (Character.isLowerCase(s1.charAt(0))) {
            s1.setCharAt(0, Character.toUpperCase(s1.charAt(0)));
        }
        int length = s1.length();
        for (int j = 1; j < length; j++)
            if (Character.isUpperCase(s1.charAt(j))) {
                s1.setCharAt(j, Character.toLowerCase(s1.charAt(j)));
            }
        return s1;
    }

    /**
     * Loads a list of words from the array and stores them in a HashSet.
     */
    private static Set<CharSequence> loadVerbStemSet() {
        Set<CharSequence> set = Generics.<CharSequence>newHashSet(VERBSTEMS.verbStems.length);
        Collections.addAll(set, VERBSTEMS.verbStems);
        return set;
    }

    CharSequence condub_stem(int del, CharSequence affix) {
        TxtBuilder yytextBuff = new TxtBuilder(changeCase() ? yytext().toLowerCase() : yytext());
        int stem_length = yylength() - del;
        char d = yytextBuff.charAt(stem_length - 1);
        if (del > 0) yytextBuff.setLength(stem_length - 1);
        if (!verbStemSet.contains(yytextBuff.toString().toLowerCase())) yytextBuff.append(d);
        return option(print_affixes) ? yytextBuff.append('+').append(affix) : yytextBuff;
    }

    private boolean changeCase() {
        return option(change_case);
    }

    /**
     * word is a singular- or plural-only noun.
     */
    CharSequence xnull_stem() {
        return common_noun_stem();
    }

    /**
     * this form is actually the stem so don't apply any generic analysis rules.
     */
    CharSequence cnull_stem() {
        return common_noun_stem();
    }

    /**
     * the +ed/+en form is the same as the stem
     */
    CharSequence null_stem() {
        return common_noun_stem();
    }

    /**
     * Delete del letters from end of token, and append string add to give stem.
     * Return affix as the affix of the word.
     */
    private CharSequence stem(int del, CharSequence add, CharSequence affix) {
        int stem_length = yylength() - del;
        Txt result = yytext().subtext(0, stem_length);
        if (changeCase()) result = result.toLowerCase();
        if (add.length() != 0) result = result.plus(add);
        return option(print_affixes) ? result.plus("+").plus(affix) : result;
    }

    private CharSequence semi_reg_stem(int del, CharSequence add) {
        int stem_length = 0;
        int i = 0;
        CharSequence affix = "";

        CharSequence yytext = yytext();
        int yyleng = yylength();

        char c = yytext.charAt(yyleng - 1);
        switch (c) {
            case 's':
                break;
            case 'S':
                stem_length = yyleng - 2 - del;
                affix = "s";
                break;
            case 'd':
                break;
            case 'D':
                stem_length = yyleng - 2 - del;
                affix = "ed";
                break;
            case 'g':
                break;
            case 'G':
                stem_length = yyleng - 3 - del;
                affix = "ing";
                break;
        }

        Txt result;
        {

            Txt seq = yytext().subtext(0, stem_length);
            result = changeCase() ? (seq.toLowerCase()) : (seq);
        }

        result.plus(result).plus(add);
        return option(print_affixes) ? result.plus(result).plus("+").plus(affix) : result;
    }

    /**
     * Creates a new scanner There is also a java.io.InputStream version of this
     * constructor.
     *
     * @param in the java.io.Reader to read input from.
     */
    Morpha(java.io.Reader in) {
        options = new boolean[NUM_OPTIONS];
        for (int j = 0; j < options.length; j++) {
            options[j] = true;
        }
        options[0] = false;
        verbStemSet = loadVerbStemSet();
        if (noTags) {
            yybegin(any);
        } else {
            yybegin(scan);
        }
        this.zzReader = in;
    }

    /**
     * Creates a new scanner. There is also java.io.Reader version of this
     * constructor.
     *
     * @param in the java.io.Inputstream to read input from.
     */
    Morpha(java.io.InputStream in) {
        this(new java.io.InputStreamReader(in));
    }

    /**
     * Unpacks the compressed character translation table.
     *
     * @return the unpacked character translation table
     */
    private static char[] zzUnpackCMap() {
        char[] map = new char[0x10000];
        int i = 0;  /* index in packed string  */

        int j = 0;  /* index in unpacked array */

        while (i < 156) {
            int count = Morpha.ZZ_CMAP_PACKED.charAt(i++);
            char value = Morpha.ZZ_CMAP_PACKED.charAt(i++);
            do {
                map[j++] = value;
            } while (--count > 0);
        }
        return map;
    }

    /**
     * Refills the input buffer.
     *
     * @return      <code>false</code>, iff there was new input.
     *
     * @exception java.io.IOException if any I/O-Error occurs
     */
    private boolean zzRefill() throws java.io.IOException {

        /* first: make room (if you can) */        if (zzStartRead > 0) {
            System.arraycopy(zzBuffer, zzStartRead,
                    zzBuffer, 0,
                    zzEndRead - zzStartRead);

            /* translate stored positions */            zzEndRead -= zzStartRead;
            zzCurrentPos -= zzStartRead;
            zzMarkedPos -= zzStartRead;
            zzStartRead = 0;
        }

        /* is the buffer big enough? */
        if (zzCurrentPos >= zzBuffer.length) {
            /* if not: blow it up */
            char newBuffer[] = new char[(zzCurrentPos << 1)];
            System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
            zzBuffer = newBuffer;
        }

        /* finally: fill the buffer with new input */        int numRead = zzReader.read(zzBuffer, zzEndRead,
                zzBuffer.length - zzEndRead);

        if (numRead > 0) {
            zzEndRead += numRead;
            return false;
        }
        // unlikely but not impossible: read 0 characters, but not at end of stream    
        if (numRead == 0) {
            int c = zzReader.read();
            if (c == -1) {
                return true;
            } else {
                zzBuffer[zzEndRead++] = (char) c;
                return false;
            }
        }

        // numRead < 0
        return true;
    }

    /**
     * Resets the scanner to read from a new input stream. Does not close the
     * old reader.
     *
     * All internal variables are reset, the old input stream
     * <b>cannot</b> be reused (internal buffer is discarded and lost). Lexical
     * state is set to <tt>ZZ_INITIAL</tt>.
     *
     * @param reader the new input stream
     */
    public void yyreset(java.io.Reader reader) {
        zzReader = reader;
        /*
      zzAtBOL == true <=> the scanner is currently at the beginning of a line
     */
        zzAtEOF = false;
        /*
      denotes if the user-EOF-code has already been executed
     */
        boolean zzEOFDone = false;
        zzEndRead = zzStartRead = 0;
        zzCurrentPos = zzMarkedPos = 0;
        /*
      number of newlines encountered up to the start of the matched text
     */
        /*
      the number of characters from the last newline up to the start of the
      matched text
     */
        zzLexicalState = YYINITIAL;
    }

    /**
     * Enters a new lexical state
     *
     * @param newState the new lexical state
     */
    public void yybegin(int newState) {
        zzLexicalState = newState;
    }

    /**
     * Returns the text matched by the current regular expression.
     */
    Txt yytext() {
    return     Txt.valueOf(zzBuffer, zzStartRead, zzMarkedPos - zzStartRead);
    }

    /**
     * Returns the length of the matched text region.
     */
    int yylength() {
        return zzMarkedPos - zzStartRead;
    }

    /**
     * Reports an error that occured while scanning.
     *
     * In a wellformed scanner (no or only correct usage of yypushback(int) and
     * a match-all fallback rule) this method will only be called with things
     * that "Can't Possibly Happen". If this method is called, something is
     * seriously wrong (e.g. a JFlex bug producing a faulty scanner etc.).
     *
     * Usual syntax/scanner level error handling should be done in error
     * fallback rules.
     *
     * @param errorCode the code of the errormessage to display
     */
    private static void zzScanError(int errorCode) {
        CharSequence message;
        try {
            message = ZZ_ERROR_MSG[errorCode];
        } catch (ArrayIndexOutOfBoundsException e) {
            message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
        }

        throw new Error(message.toString());
    }

    /**
     * Pushes the specified amount of characters back into the input stream.
     *
     * They will be read again by then next call of the scanning method
     *
     * @param number the number of characters to be read again. This number must
     * not be greater than yylength()!
     */
    void yypushback(int number) {
        if (number > yylength()) {
            zzScanError(ZZ_PUSHBACK_2BIG);
        }

        zzMarkedPos -= number;
    }

    /**
     * Resumes scanning until the next regular expression is matched, the end of
     * input is encountered or an I/O-Error occurs.
     *
     * @return the next token
     * @exception java.io.IOException if any I/O-Error occurs
     */
    public CharSequence next() throws java.io.IOException {

        // cached fields:
        int zzEndReadL = zzEndRead;
        char[] zzBufferL = zzBuffer;
        char[] zzCMapL = ZZ_CMAP;

        int[] zzTransL = ZZ_TRANS;
        int[] zzRowMapL = ZZ_ROWMAP;
        int[] zzAttrL = ZZ_ATTRIBUTE;

        while (true) {
            int zzMarkedPosL = zzMarkedPos;

            int zzAction = -1;

            int zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;

            /*
      the current state of the DFA
     */
            int zzState = ZZ_LEXSTATE[zzLexicalState];

            int zzInput;
            zzForAction:
            {
                while (true) {

                    if (zzCurrentPosL >= zzEndReadL) {
                        if (zzAtEOF) {
                            zzInput = YYEOF;
                            break zzForAction;
                        } else {
                            // store back cached positions
                            zzCurrentPos = zzCurrentPosL;
                            zzMarkedPos = zzMarkedPosL;
                            boolean eof = zzRefill();
                            // get translated positions and possibly new buffer
                            zzCurrentPosL = zzCurrentPos;
                            zzMarkedPosL = zzMarkedPos;
                            zzBufferL = zzBuffer;
                            zzEndReadL = zzEndRead;
                            if (!eof) {
                                zzInput = zzBufferL[zzCurrentPosL++];
                            } else {
                                zzInput = YYEOF;
                                break zzForAction;
                            }
                        }
                    } else zzInput = zzBufferL[zzCurrentPosL++];
                    int zzNext = zzTransL[ zzRowMapL[zzState] + (int) zzCMapL[zzInput]];
                    switch (zzNext) {
                        case -1:
                            break zzForAction;
                    }
                    zzState = zzNext;

                    int zzAttributes = zzAttrL[zzState];
                    switch ((zzAttributes & 1)) {
                        case 1:
                            zzAction = zzState;
                            zzMarkedPosL = zzCurrentPosL;
                            switch ((zzAttributes & 8)) {
                                case 8:
                                    break zzForAction;
                            }
                            break;
                    }

                }
            }

            // store back cached position
            zzMarkedPos = zzMarkedPosL;

            switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
                case 180: {
                    return (stem(3, "te", "ed"));
                }
                case 373:
                    break;
                case 298: {
                    return (stem(1, "a", "s"));
                }
                case 374:
                    break;
                case 94: {
                    return (stem(3, "ide", "ed"));
                }
                case 375:
                    break;
                case 126: {
                    return (stem(2, "al", "s"));
                }
                case 376:
                    break;
                case 15: {
                    return (null_stem());
                }
                case 377:
                    break;
                case 293: {
                    return (stem(2, "la", "s"));
                }
                case 378:
                    break;
                case 38: {
                    return (stem(3, "will", ""));
                }
                case 379:
                    break;
                case 8: {
                    yybegin(scan);
                    if (option(tag_output)) {
                        return yytext();
                    }
                }
                break;
                case 380:
                    break;
                case 11: {
                    return cnull_stem();
                }
                case 381:
                    break;
                case 72: {
                    return (stem(3, "eel", "ed"));
                }
                case 382:
                    break;
                case 173: {
                    return (stem(3, "eal", "ed"));
                }
                case 383:
                    break;
                case 177: {
                    return (stem(4, "ake", "en"));
                }
                case 384:
                    break;
                case 134:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 2; {
                        return (stem(2, "I", ""));
                    }
                case 385:
                    break;
                case 133:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 2; {
                        return (stem(1, "y", ""));
                    }
                case 386:
                    break;
                case 259:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 4; {
                        return (stem(1, "y", ""));
                    }
                case 387:
                    break;
                case 89: {
                    return (stem(3, "ay", "ed"));
                }
                case 388:
                    break;
                case 272: {
                    return (stem(3, "se", "ed"));
                }
                case 389:
                    break;
                case 95: {
                    return (stem(3, "ise", "ed"));
                }
                case 390:
                    break;
                case 236: {
                    return (stem(3, "ike", "ed"));
                }
                case 391:
                    break;
                case 29: {
                    return (ynull_stem());
                }
                case 392:
                    break;
                case 111: {
                    return (stem(3, "ell", "ed"));
                }
                case 393:
                    break;
                case 10: {
                    return (stem(1, "us", "s"));
                }
                case 394:
                    break;
                case 1: {
                    return (common_noun_stem());
                }
                case 395:
                    break;
                case 13:
                    // lookahead expression with fixed lookahead length
                    yypushback(1); {
                        return (common_noun_stem());
                    }
                case 396:
                    break;
                case 70: {
                    return (stem(3, "ly", "ed"));
                }
                case 397:
                    break;
                case 67: {
                    return (stem(3, "ive", "ed"));
                }
                case 398:
                    break;
                case 356: {
                    return (stem(3, "is", "s"));
                }
                case 399:
                    break;
                case 239: {
                    return (stem(5, "eek", "ed"));
                }
                case 400:
                    break;
                case 160: {
                    return (stem(3, "ar", "ed"));
                }
                case 401:
                    break;
                case 267: {
                    return (stem(4, "ame", "ed"));
                }
                case 402:
                    break;
                case 33: {
                    return (stem(3, "see", "ed"));
                }
                case 403:
                    break;
                case 151: {
                    return (stem(3, "epe", "ed"));
                }
                case 404:
                    break;
                case 21: {
                    return (stem(3, "get", "ed"));
                }
                case 405:
                    break;
                case 352: {
                    return (stem(8, "-de-sac", "s"));
                }
                case 406:
                    break;
                case 370: {
                    return (stem(12, "-in-the-box", "s"));
                }
                case 407:
                    break;
                case 266: {
                    return (stem(5, "ing", "ed"));
                }
                case 408:
                    break;
                case 182: {
                    return (stem(2, "i", "s"));
                }
                case 409:
                    break;
                case 162: {
                    return (stem(3, "an", "ed"));
                }
                case 410:
                    break;
                case 30: {
                    return (stem(3, "red", "ed"));
                }
                case 411:
                    break;
                case 51: {
                    return (stem(3, "e", "ing"));
                }
                case 412:
                    break;
                case 214: {
                    return (stem(3, "ass", "ed"));
                }
                case 413:
                    break;
                case 249: {
                    return (stem(2, "re", "s"));
                }
                case 414:
                    break;
                case 65: {
                    return (stem(2, "e", "s"));
                }
                case 415:
                    break;
                case 78: {
                    return (stem(3, "o", "en"));
                }
                case 416:
                    break;
                case 155: {
                    return (stem(5, "do", "ed"));
                }
                case 417:
                    break;
                case 71: {
                    return (stem(3, "all", "ed"));
                }
                case 418:
                    break;
                case 125: {
                    return (stem(2, "ra", "s"));
                }
                case 419:
                    break;
                case 212: {
                    return (stem(6, "clepe", "ed"));
                }
                case 420:
                    break;
                case 256:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 4; {
                        return (stem(1, "", ""));
                    }
                case 421:
                    break;
                case 60: {
                    return (stem(3, "ear", "ed"));
                }
                case 422:
                    break;
                case 63: {
                    return (stem(3, "ome", "ed"));
                }
                case 423:
                    break;
                case 52: {
                    return (stem(1, "", "ed"));
                }
                case 424:
                    break;
                case 157: {
                    return (stem(3, "eeze", "ed"));
                }
                case 425:
                    break;
                case 27: {
                    return (stem(3, "light", "ed"));
                }
                case 426:
                    break;
                case 139: {
                    return (stem(3, "y", "s"));
                }
                case 427:
                    break;
                case 296: {
                    return (stem(2, "zo", "s"));
                }
                case 428:
                    break;
                case 31: {
                    return (stem(3, "run", "ed"));
                }
                case 429:
                    break;
                case 46: {
                    return (stem(2, "an", "s"));
                }
                case 430:
                    break;
                case 333: {
                    return (stem(3, "ix", "ed"));
                }
                case 431:
                    break;
                case 304: {
                    return (stem(4, "g", "ing"));
                }
                case 432:
                    break;
                case 57: {
                    return (stem(3, "end", "ed"));
                }
                case 433:
                    break;
                case 131: // general lookahead, find correct zzMarkedPos
                {
                    int zzFPos = zzStartRead;
                    if (zzFin.length <= zzBufferL.length) {
                        zzFin = new boolean[zzBufferL.length + 1];
                    }
                    boolean zzFinL[] = zzFin;
                    int zzFState = 5;
                    while (zzFState != -1 && zzFPos < zzMarkedPos) {
                        if ((zzAttrL[zzFState] & 1) == 1) {
                            zzFinL[zzFPos] = true;
                        }
                        zzInput = zzBufferL[zzFPos++];
                        zzFState = zzTransL[ zzRowMapL[zzFState] + (int) zzCMapL[zzInput]];
                    }
                    if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) {
                        zzFinL[zzFPos] = true;
                    }

                    zzFState = 7;
                    zzFPos = zzMarkedPos;
                    while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                        zzInput = zzBufferL[--zzFPos];
                        zzFState = zzTransL[ zzRowMapL[zzFState] + (int) zzCMapL[zzInput]];
                    };
                    zzMarkedPos = zzFPos;
                } {
                    return (proper_name_stem());
                }
                case 434:
                    break;
                case 50:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 1; {
                        return (proper_name_stem());
                    }
                case 435:
                    break;
                case 55: {
                    return (stem(3, "low", "ed"));
                }
                case 436:
                    break;
                case 193: {
                    return (stem(2, "ny", "s"));
                }
                case 437:
                    break;
                case 138: {
                    return (stem(3, "y", "ed"));
                }
                case 438:
                    break;
                case 104: {
                    return (stem(3, "mite", "ed"));
                }
                case 439:
                    break;
                case 305: {
                    return (stem(3, "d", "en"));
                }
                case 440:
                    break;
                case 14: {
                    return (stem(2, "e", "ed"));
                }
                case 441:
                    break;
                case 100: {
                    return (stem(3, "hoot", "ed"));
                }
                case 442:
                    break;
                case 185: {
                    return (stem(2, "so", "s"));
                }
                case 443:
                    break;
                case 341: {
                    return (stem(2, "r", "s"));
                }
                case 444:
                    break;
                case 231: {
                    return (stem(5, "elt", "en"));
                }
                case 445:
                    break;
                case 225: {
                    return stem(4, "eeze", "en");
                }
                case 446:
                    break;
                case 332: {
                    return (stem(4, "y", "ing"));
                }
                case 447:
                    break;
                case 130: // general lookahead, find correct zzMarkedPos
                {
                    int zzFPos = zzStartRead;
                    if (zzFin.length <= zzBufferL.length) {
                        zzFin = new boolean[zzBufferL.length + 1];
                    }
                    boolean zzFinL[] = zzFin;
                    int zzFState = 5;
                    while (zzFState != -1 && zzFPos < zzMarkedPos) {
                        if ((zzAttrL[zzFState] & 1) == 1) {
                            zzFinL[zzFPos] = true;
                        }
                        zzInput = zzBufferL[zzFPos++];
                        zzFState = zzTransL[ zzRowMapL[zzFState] + (int) zzCMapL[zzInput]];
                    }
                    if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) {
                        zzFinL[zzFPos] = true;
                    }

                    zzFState = 6;
                    zzFPos = zzMarkedPos;
                    while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                        zzInput = zzBufferL[--zzFPos];
                        zzFState = zzTransL[ zzRowMapL[zzFState] + (int) zzCMapL[zzInput]];
                    };
                    zzMarkedPos = zzFPos;
                } {
                    yybegin(noun);
                    yypushback(yylength());
                    return (next());
                }
                case 448:
                    break;
                case 81: {
                    return (stem(3, "ew", "en"));
                }
                case 449:
                    break;
                case 113: {
                    return (stem(3, "aw", "en"));
                }
                case 450:
                    break;
                case 49:
                    // lookahead expression with fixed lookahead length
                    yypushback(2); {
                        yybegin(verb);
                        yypushback(yylength());
                        return (next());
                    }
                case 451:
                    break;
                case 314: {
                    return (stem(3, "ship", "ed"));
                }
                case 452:
                    break;
                case 335: {
                    return (stem(1, "de", "s"));
                }
                case 453:
                    break;
                case 365: {
                    return (stem(9, "-mutuel", "s"));
                }
                case 454:
                    break;
                case 371: {
                    return (stem(14, "y-in-waiting", "s"));
                }
                case 455:
                    break;
                case 9: {
                    return (stem(2, "be", ""));
                }
                case 456:
                    break;
                case 206:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 2; {
                        return (stem(2, "be", ""));
                    }
                case 457:
                    break;
                case 69: {
                    return (stem(3, "lee", "ed"));
                }
                case 458:
                    break;
                case 40: {
                    return (stem(1, "um", "s"));
                }
                case 459:
                    break;
                case 56: {
                    return (stem(3, "reed", "ed"));
                }
                case 460:
                    break;
                case 163: {
                    return (stem(3, "ap", "ed"));
                }
                case 461:
                    break;
                case 344: {
                    return (stem(2, "te", "s"));
                }
                case 462:
                    break;
                case 197: {
                    return (stem(3, "f", "s"));
                }
                case 463:
                    break;
                case 200:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 2; {
                        return (stem(2, "can", ""));
                    }
                case 464:
                    break;
                case 300: {
                    return (stem(2, "lio", "s"));
                }
                case 465:
                    break;
                case 108: {
                    return (stem(3, "wim", "en"));
                }
                case 466:
                    break;
                case 91: {
                    return (stem(3, "ow", "en"));
                }
                case 467:
                    break;
                case 321: {
                    return (stem(2, "g", "s"));
                }
                case 468:
                    break;
                case 228: {
                    return (semi_reg_stem(1, ""));
                }
                case 469:
                    break;
                case 275: {
                    return (stem(2, "gue", "s"));
                }
                case 470:
                    break;
                case 143: {
                    return (stem(3, "ei", "ed"));
                }
                case 471:
                    break;
                case 37: {
                    return (stem(3, "eat", "ed"));
                }
                case 472:
                    break;
                case 17: {
                    return (stem(3, "bid", "ed"));
                }
                case 473:
                    break;
                case 217: {
                    return (stem(3, "", "en"));
                }
                case 474:
                    break;
                case 355: {
                    return (stem(10, "an-at-arms", "s"));
                }
                case 475:
                    break;
                case 132:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 2; {
                        return (stem(2, "we", ""));
                    }
                case 476:
                    break;
                case 244: {
                    return (stem(2, "ron", "s"));
                }
                case 477:
                    break;
                case 338: {
                    return (stem(2, "non", "s"));
                }
                case 478:
                    break;
                case 196: {
                    return (stem(2, "uum", "s"));
                }
                case 479:
                    break;
                case 24: {
                    return (stem(3, "have", "ed"));
                }
                case 480:
                    break;
                case 345: {
                    return (stem(3, "ff", "s"));
                }
                case 481:
                    break;
                case 251: {
                    return (stem(2, "mum", "s"));
                }
                case 482:
                    break;
                case 242: {
                    return (stem(2, "ie", "ed"));
                }
                case 483:
                    break;
                case 273: {
                    return (stem(2, "ee", "ed"));
                }
                case 484:
                    break;
                case 334: {
                    return (stem(2, "do", "s"));
                }
                case 485:
                    break;
                case 262:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 2; {
                        return (stem(2, "do", "s"));
                    }
                case 486:
                    break;
                case 361: {
                    return (stem(6, "-doux", "s"));
                }
                case 487:
                    break;
                case 299: {
                    return (stem(3, "ly", "s"));
                }
                case 488:
                    break;
                case 224: {
                    return (stem(4, "w", "ed"));
                }
                case 489:
                    break;
                case 237: {
                    return (stem(4, "eal", "en"));
                }
                case 490:
                    break;
                case 253: {
                    return (stem(6, "m.p.", "s"));
                }
                case 491:
                    break;
                case 45: {
                    return (stem(2, "", "s"));
                }
                case 492:
                    break;
                case 347: {
                    return (stem(9, "an-of-war", "s"));
                }
                case 493:
                    break;
                case 90: {
                    return (stem(3, "ie", "en"));
                }
                case 494:
                    break;
                case 121: {
                    return (stem(2, "tum", "s"));
                }
                case 495:
                    break;
                case 199: {
                    return (stem(5, "eyrir", "s"));
                }
                case 496:
                    break;
                case 110: {
                    return (stem(3, "ee", "en"));
                }
                case 497:
                    break;
                case 204:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 2; {
                        return (stem(2, "will", ""));
                    }
                case 498:
                    break;
                case 250: {
                    return (stem(2, "ia", "s"));
                }
                case 499:
                    break;
                case 255: {
                    return (stem(3, "s", "s"));
                }
                case 500:
                    break;
                case 44: {
                    return (stem(2, "uo", "s"));
                }
                case 501:
                    break;
                case 226: {
                    return (stem(5, "ight", "ed"));
                }
                case 502:
                    break;
                case 124: {
                    return (stem(3, "ouse", "s"));
                }
                case 503:
                    break;
                case 359: {
                    return (stem(2, "t", "s"));
                }
                case 504:
                    break;
                case 7: {
                    return (stem(2, "be", "s"));
                }
                case 505:
                    break;
                case 260:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 2; {
                        return (stem(2, "be", "s"));
                    }
                case 506:
                    break;
                case 53: {
                    return (semi_reg_stem(0, "e"));
                }
                case 507:
                    break;
                case 357: {
                    return (stem(8, "-in-law", "s"));
                }
                case 508:
                    break;
                case 181: {
                    return (stem(4, ".", "s"));
                }
                case 509:
                    break;
                case 169: {
                    return (stem(3, "ay", "en"));
                }
                case 510:
                    break;
                case 165: {
                    return (stem(3, "se", "en"));
                }
                case 511:
                    break;
                case 39: {
                    return (stem(3, "have", ""));
                }
                case 512:
                    break;
                case 3: { // The first word isn't stemmed separately, but the second half can be
                    CharSequence stem = common_noun_stem();
                    CharSequence n = next();
                    return n == null ? stem : stem+(n.toString());
                }
                case 513:
                    break;
                case 166: {
                    return (stem(3, "ine", "ed"));
                }
                case 514:
                    break;
                case 278: {
                    return (stem(5, "ink", "ed"));
                }
                case 515:
                    break;
                case 326:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 4; {
                        return (stem(4, "be", "ed"));
                    }
                case 516:
                    break;
                case 116: {
                    return (stem(4, "be", "ed"));
                }
                case 517:
                    break;
                case 360: {
                    return (stem(9, "-down", "ing"));
                }
                case 518:
                    break;
                case 297: {
                    return (stem(3, "en", "s"));
                }
                case 519:
                    break;
                case 148: {
                    return (stem(4, "ear", "en"));
                }
                case 520:
                    break;
                case 362: {
                    return (stem(8, "-de-lys", "s"));
                }
                case 521:
                    break;
                case 115: {
                    return (stem(4, "go", "ed"));
                }
                case 522:
                    break;
                case 309: {
                    return (stem(4, "y", "ed"));
                }
                case 523:
                    break;
                case 42: {
                    return (stem(2, "a", "s"));
                }
                case 524:
                    break;
                case 189: {
                    return (stem(3, "x", "s"));
                }
                case 525:
                    break;
                case 61: {
                    return (stem(3, "id", "ed"));
                }
                case 526:
                    break;
                case 83: {
                    return (stem(4, "have", "s"));
                }
                case 527:
                    break;
                case 59: {
                    return (stem(3, "ear", "en"));
                }
                case 528:
                    break;
                case 96: {
                    return (stem(3, "eeve", "ed"));
                }
                case 529:
                    break;
                case 76: {
                    return (stem(3, "ild", "ed"));
                }
                case 530:
                    break;
                case 354: {
                    return (stem(10, "anservant", "s"));
                }
                case 531:
                    break;
                case 202:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 3; {
                        return (stem(3, "he", ""));
                    }
                case 532:
                    break;
                case 254: {
                    return (stem(4, "ex", "s"));
                }
                case 533:
                    break;
                case 150: {
                    return (stem(3, "oose", "ed"));
                }
                case 534:
                    break;
                case 336: {
                    return (stem(4, "-in", "s"));
                }
                case 535:
                    break;
                case 285: {
                    return (stem(6, "ork", "ed"));
                }
                case 536:
                    break;
                case 144: {
                    return (stem(3, "eak", "ed"));
                }
                case 537:
                    break;
                case 112: {
                    return (stem(3, "ink", "ed"));
                }
                case 538:
                    break;
                case 241: {
                    return (stem(3, "a", "ed"));
                }
                case 539:
                    break;
                case 141: {
                    return (stem(3, "rn", "ed"));
                }
                case 540:
                    break;
                case 330: {
                    return (stem(6, "-up", "ed"));
                }
                case 541:
                    break;
                case 156: {
                    return (stem(3, "y", "en"));
                }
                case 542:
                    break;
                case 119: {
                    return (stem(2, "um", "s"));
                }
                case 543:
                    break;
                case 222: {
                    return (stem(4, "tch", "ed"));
                }
                case 544:
                    break;
                case 88: {
                    return (stem(3, "ose", "ed"));
                }
                case 545:
                    break;
                case 25: {
                    return (stem(3, "have", "s"));
                }
                case 546:
                    break;
                case 101: {
                    return (stem(3, "hit", "ed"));
                }
                case 547:
                    break;
                case 122: {
                    return (stem(3, "oot", "s"));
                }
                case 548:
                    break;
                case 68: {
                    return (stem(4, "do", "s"));
                }
                case 549:
                    break;
                case 97: {
                    return (stem(3, "ing", "ed"));
                }
                case 550:
                    break;
                case 246: {
                    return (stem(3, "denum", "s"));
                }
                case 551:
                    break;
                case 353: {
                    return (stem(6, "-over", "s"));
                }
                case 552:
                    break;
                case 191: {
                    return (stem(1, "s", "s"));
                }
                case 553:
                    break;
                case 34: {
                    return (stem(3, "win", "ed"));
                }
                case 554:
                    break;
                case 82: {
                    return (stem(3, "eave", "ed"));
                }
                case 555:
                    break;
                case 343: {
                    return (stem(7, "-up", "ing"));
                }
                case 556:
                    break;
                case 74: {
                    return (stem(3, "eld", "ed"));
                }
                case 557:
                    break;
                case 289: {
                    return (stem(4, "yatid", "s"));
                }
                case 558:
                    break;
                case 342: {
                    return (stem(4, "us", "s"));
                }
                case 559:
                    break;
                case 291: {
                    return (stem(1, "o", "s"));
                }
                case 560:
                    break;
                case 127: {
                    return (stem(2, "lo", "s"));
                }
                case 561:
                    break;
                case 103: {
                    return (stem(3, "lide", "ed"));
                }
                case 562:
                    break;
                case 41: {
                    return (stem(2, ".", "s"));
                }
                case 563:
                    break;
                case 175: {
                    return (stem(3, "and", "ed"));
                }
                case 564:
                    break;
                case 223: {
                    return (stem(3, "am", "ed"));
                }
                case 565:
                    break;
                case 114: {
                    return (stem(3, "read", "ed"));
                }
                case 566:
                    break;
                case 263:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 2; {
                        return (stem(2, "have", "s"));
                    }
                case 567:
                    break;
                case 350: {
                    return (stem(8, "-down", "ed"));
                }
                case 568:
                    break;
                case 209:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 2; {
                        return (stem(2, "have", "ed"));
                    }
                case 569:
                    break;
                case 137: {
                    return (stem(3, "", "ing"));
                }
                case 570:
                    break;
                case 146: {
                    return (stem(5, "be", "ing"));
                }
                case 571:
                    break;
                case 219: {
                    return (stem(4, "te", "ing"));
                }
                case 572:
                    break;
                case 322: {
                    return (stem(4, "isee", "s"));
                }
                case 573:
                    break;
                case 118: {
                    return (stem(1, "on", "s"));
                }
                case 574:
                    break;
                case 117: {
                    return (stem(2, "", "ed"));
                }
                case 575:
                    break;
                case 307: {
                    return (stem(4, "y", "s"));
                }
                case 576:
                    break;
                case 346: {
                    return (stem(4, "-on", "s"));
                }
                case 577:
                    break;
                case 337: {
                    return (stem(8, "onsieur", "s"));
                }
                case 578:
                    break;
                case 178: {
                    return (stem(4, "eave", "en"));
                }
                case 579:
                    break;
                case 248: {
                    return (stem(3, "us", "s"));
                }
                case 580:
                    break;
                case 366: {
                    return (stem(9, "-de-camp", "s"));
                }
                case 581:
                    break;
                case 201:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 3; {
                        return (stem(3, "she", ""));
                    }
                case 582:
                    break;
                case 64: {
                    return (stem(3, "raw", "ed"));
                }
                case 583:
                    break;
                case 317: {
                    return (stem(2, "cio", "s"));
                }
                case 584:
                    break;
                case 372: {
                    return (stem(11, "y-general", "s"));
                }
                case 585:
                    break;
                case 320: {
                    return (stem(2, "eum", "s"));
                }
                case 586:
                    break;
                case 369: {
                    return (stem(9, "-at-arms", "s"));
                }
                case 587:
                    break;
                case 315: {
                    return (stem(2, "ion", "s"));
                }
                case 588:
                    break;
                case 368: {
                    return (stem(11, "erfamilias", "s"));
                }
                case 589:
                    break;
                case 328: {
                    return (stem(6, "-down", "s"));
                }
                case 590:
                    break;
                case 288: {
                    return (stem(1, "x", "s"));
                }
                case 591:
                    break;
                case 323: {
                    return (stem(2, "oan", "s"));
                }
                case 592:
                    break;
                case 306: {
                    return (stem(5, "eech", "ed"));
                }
                case 593:
                    break;
                case 73: {
                    return (stem(3, "row", "ed"));
                }
                case 594:
                    break;
                case 4: {
                    return yytext();
                }
                case 595:
                    break;
                case 292: {
                    return (stem(2, "ro", "s"));
                }
                case 596:
                    break;
                case 252: {
                    return (stem(3, "ey", "s"));
                }
                case 597:
                    break;
                case 324: {
                    return (stem(2, "ton", "s"));
                }
                case 598:
                    break;
                case 5: {
                    return (stem(1, "", "s"));
                }
                case 599:
                    break;
                case 303:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 3; {
                        return (stem(3, "be", ""));
                    }
                case 600:
                    break;
                case 36: {
                    return (stem(3, "be", ""));
                }
                case 601:
                    break;
                case 229: {
                    return (stem(5, "et", "en"));
                }
                case 602:
                    break;
                case 99: {
                    return (stem(3, "hoe", "ed"));
                }
                case 603:
                    break;
                case 164: {
                    return (stem(3, "de", "en"));
                }
                case 604:
                    break;
                case 43: {
                    return (xnull_stem());
                }
                case 605:
                    break;
                case 363: {
                    return (stem(8, "-de-lis", "s"));
                }
                case 606:
                    break;
                case 207:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 2; {
                        return (stem(2, "have", ""));
                    }
                case 607:
                    break;
                case 271: {
                    return (stem(5, "ivy", "s"));
                }
                case 608:
                    break;
                case 238: {
                    return (stem(3, "ge", "ed"));
                }
                case 609:
                    break;
                case 233: {
                    return (stem(3, "ce", "ed"));
                }
                case 610:
                    break;
                case 176: {
                    return (stem(3, "ke", "en"));
                }
                case 611:
                    break;
                case 105: {
                    return (stem(3, "pin", "ed"));
                }
                case 612:
                    break;
                case 287: {
                    return (stem(2, "no", "s"));
                }
                case 613:
                    break;
                case 312: {
                    return (semi_reg_stem(0, "ue"));
                }
                case 614:
                    break;
                case 235: {
                    return (stem(3, "il", "ed"));
                }
                case 615:
                    break;
                case 351: {
                    return (stem(2, "l", "s"));
                }
                case 616:
                    break;
                case 167: {
                    return (semi_reg_stem(0, ""));
                }
                case 617:
                    break;
                case 159: {
                    return (stem(3, "ve", "en"));
                }
                case 618:
                    break;
                case 203:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 3; {
                        return (stem(2, "e", ""));
                    }
                case 619:
                    break;
                case 234: {
                    return (stem(5, "ink", "en"));
                }
                case 620:
                    break;
                case 145: {
                    return (stem(3, "gin", "ed"));
                }
                case 621:
                    break;
                case 286: {
                    return (stem(5, "y", "ed"));
                }
                case 622:
                    break;
                case 205:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 3; {
                        return (stem(3, "we", ""));
                    }
                case 623:
                    break;
                case 171: {
                    return (stem(3, "ill", "ed"));
                }
                case 624:
                    break;
                case 232: {
                    return (stem(3, "ue", "ed"));
                }
                case 625:
                    break;
                case 245: {
                    return (stem(1, "i", "s"));
                }
                case 626:
                    break;
                case 183: {
                    return (stem(2, "d", "s"));
                }
                case 627:
                    break;
                case 19: {
                    return (stem(3, "do", "ed"));
                }
                case 628:
                    break;
                case 58: {
                    return (stem(4, "be", "en"));
                }
                case 629:
                    break;
                case 270: {
                    return (stem(5, "ivy", "ed"));
                }
                case 630:
                    break;
                case 168: {
                    return (stem(3, "i", "ed"));
                }
                case 631:
                    break;
                case 187: {
                    return (stem(1, "e", "s"));
                }
                case 632:
                    break;
                case 340: {
                    return (stem(2, "le", "s"));
                }
                case 633:
                    break;
                case 280: {
                    return (stem(5, "ead", "en"));
                }
                case 634:
                    break;
                case 301:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 5; {
                        return (stem(2, "y", ""));
                    }
                case 635:
                    break;
                case 149: {
                    return (stem(3, "rse", "ed"));
                }
                case 636:
                    break;
                case 66: {
                    return (stem(4, "do", "en"));
                }
                case 637:
                    break;
                case 170: {
                    return (stem(3, "ite", "ed"));
                }
                case 638:
                    break;
                case 227: {
                    return (stem(3, "l", "en"));
                }
                case 639:
                    break;
                case 128: {
                    return (stem(4, "ABC", "s"));
                }
                case 640:
                    break;
                case 106: {
                    return (stem(3, "peed", "ed"));
                }
                case 641:
                    break;
                case 215: {
                    return (stem(4, "eak", "en"));
                }
                case 642:
                    break;
                case 28: {
                    return (stem(3, "meet", "ed"));
                }
                case 643:
                    break;
                case 348: {
                    return (stem(4, "-by", "s"));
                }
                case 644:
                    break;
                case 135:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 2; {
                        return (stem(1, "", "n"));
                    }
                case 645:
                    break;
                case 325: {
                    return (stem(4, "s", "s"));
                }
                case 646:
                    break;
                case 318: {
                    return (stem(3, "esis", "s"));
                }
                case 647:
                    break;
                case 230: {
                    return (stem(3, "ey", "ed"));
                }
                case 648:
                    break;
                case 142: {
                    return (stem(3, "ess", "ed"));
                }
                case 649:
                    break;
                case 218: {
                    return (stem(3, "e", "en"));
                }
                case 650:
                    break;
                case 349: {
                    return (stem(4, "o", "s"));
                }
                case 651:
                    break;
                case 152: {
                    return (stem(4, "are", "ed"));
                }
                case 652:
                    break;
                case 147: {
                    return (stem(4, "ind", "ed"));
                }
                case 653:
                    break;
                case 172: {
                    return (stem(3, "ick", "ed"));
                }
                case 654:
                    break;
                case 153: {
                    return (stem(4, "ie", "ing"));
                }
                case 655:
                    break;
                case 107: {
                    return (stem(3, "pit", "ed"));
                }
                case 656:
                    break;
                case 184: {
                    return (stem(2, "u", "s"));
                }
                case 657:
                    break;
                case 129: {
                    return (stem(2, "to", "s"));
                }
                case 658:
                    break;
                case 268: {
                    return (stem(3, "ride", "ed"));
                }
                case 659:
                    break;
                case 186: {
                    return (stem(2, "denum", "s"));
                }
                case 660:
                    break;
                case 290: {
                    return (stem(4, "sbok", "s"));
                }
                case 661:
                    break;
                case 308: {
                    return (stem(6, "ivy", "ing"));
                }
                case 662:
                    break;
                case 367: {
                    return (stem(13, "ademoiselle", "s"));
                }
                case 663:
                    break;
                case 195: {
                    return (stem(4, "ooth", "s"));
                }
                case 664:
                    break;
                case 20: {
                    return (stem(3, "feed", "ed"));
                }
                case 665:
                    break;
                case 98: {
                    return (stem(3, "ink", "en"));
                }
                case 666:
                    break;
                case 92: {
                    return (stem(3, "ake", "ed"));
                }
                case 667:
                    break;
                case 62: {
                    return (stem(3, "lothe", "ed"));
                }
                case 668:
                    break;
                case 18: {
                    return (stem(3, "dig", "ed"));
                }
                case 669:
                    break;
                case 279: {
                    return (stem(4, "k", "ed"));
                }
                case 670:
                    break;
                case 194: {
                    return (stem(2, "po", "s"));
                }
                case 671:
                    break;
                case 221: {
                    return (stem(3, "ose", "en"));
                }
                case 672:
                    break;
                case 174: {
                    return (stem(3, "ave", "ed"));
                }
                case 673:
                    break;
                case 77: {
                    return (stem(3, "ird", "ed"));
                }
                case 674:
                    break;
                case 161: {
                    return (stem(3, "in", "ed"));
                }
                case 675:
                    break;
                case 210: {
                    return (stem(4, "", "ing"));
                }
                case 676:
                    break;
                case 85: {
                    return (stem(3, "en", "ed"));
                }
                case 677:
                    break;
                case 87: {
                    return (stem(3, "o", "ed"));
                }
                case 678:
                    break;
                case 281: {
                    return (stem(3, "mel", "s"));
                }
                case 679:
                    break;
                case 274: {
                    return (stem(4, "-up", "s"));
                }
                case 680:
                    break;
                case 12: {
                    return (stem(2, "is", "s"));
                }
                case 681:
                    break;
                case 23: {
                    return (stem(3, "hide", "ed"));
                }
                case 682:
                    break;
                case 93: {
                    return (stem(3, "ing", "en"));
                }
                case 683:
                    break;
                case 257:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 3; {
                        return (stem(3, "not", ""));
                    }
                case 684:
                    break;
                case 283: {
                    return (stem(4, "i", "ing"));
                }
                case 685:
                    break;
                case 243: {
                    return (stem(4, "e", "ing"));
                }
                case 686:
                    break;
                case 284: {
                    return (stem(4, "a", "ing"));
                }
                case 687:
                    break;
                case 136:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 2; {
                        return (stem(2, "'s", ""));
                    }
                case 688:
                    break;
                case 264: {
                    return (condub_stem(3, "ing"));
                }
                case 689:
                    break;
                case 120: {
                    return (stem(3, "a", "s"));
                }
                case 690:
                    break;
                case 327: {
                    return (stem(4, "l", "ing"));
                }
                case 691:
                    break;
                case 316: {
                    return (stem(2, "ne", "s"));
                }
                case 692:
                    break;
                case 247: {
                    return (stem(3, "ur", "s"));
                }
                case 693:
                    break;
                case 198: {
                    return (stem(2, "b", "s"));
                }
                case 694:
                    break;
                case 220: {
                    return (stem(5, "uy", "ed"));
                }
                case 695:
                    break;
                case 258:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 3; {
                        return (stem(3, "shall", ""));
                    }
                case 696:
                    break;
                case 190: {
                    return (stem(3, "fe", "s"));
                }
                case 697:
                    break;
                case 216: {
                    return (stem(2, "", "en"));
                }
                case 698:
                    break;
                case 311: {
                    return (stem(5, "ify", "s"));
                }
                case 699:
                    break;
                case 313: {
                    return (stem(5, "k", "ing"));
                }
                case 700:
                    break;
                case 6: {
                    return (cnull_stem());
                }
                case 701:
                    break;
                case 80: {
                    return (stem(3, "old", "ed"));
                }
                case 702:
                    break;
                case 339: {
                    return (stem(4, "ese", "s"));
                }
                case 703:
                    break;
                case 2: {
                    CharSequence str = yytext();
                    int first = str.charAt(0);
                    LOGGER.warning(String.format("Untokenizable: %s (U+%s, decimal: %s) - this may be because your text isn't using _ as a tag delimiter", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)).toString());
                }
                break;
                case 704:
                    break;
                case 294: {
                    return (stem(2, "dum", "s"));
                }
                case 705:
                    break;
                case 47: {
                    return (stem(2, "s", "s"));
                }
                case 706:
                    break;
                case 329: {
                    return (stem(5, "y", "ing"));
                }
                case 707:
                    break;
                case 358: {
                    return (stem(6, "-lit", "s"));
                }
                case 708:
                    break;
                case 158: {
                    return (stem(3, "ip", "ed"));
                }
                case 709:
                    break;
                case 79: {
                    return (stem(3, "ang", "ed"));
                }
                case 710:
                    break;
                case 331: {
                    return (stem(6, "ify", "ing"));
                }
                case 711:
                    break;
                case 295: {
                    return (stem(4, "belly", "s"));
                }
                case 712:
                    break;
                case 188: {
                    return (stem(4, "oose", "s"));
                }
                case 713:
                    break;
                case 282: {
                    return (stem(4, "ge", "ing"));
                }
                case 714:
                    break;
                case 109: {
                    return (stem(3, "wim", "ed"));
                }
                case 715:
                    break;
                case 179: {
                    return (stem(3, "t", "en"));
                }
                case 716:
                    break;
                case 276: {
                    return (stem(4, "ue", "ing"));
                }
                case 717:
                    break;
                case 48: {
                    return (stem(2, "vum", "s"));
                }
                case 718:
                    break;
                case 123: {
                    return (stem(2, "rum", "s"));
                }
                case 719:
                    break;
                case 192: {
                    return (stem(2, "num", "s"));
                }
                case 720:
                    break;
                case 102: {
                    return (stem(3, "lay", "ed"));
                }
                case 721:
                    break;
                case 277: {
                    return (stem(5, "ell", "en"));
                }
                case 722:
                    break;
                case 140: {
                    return (stem(3, "", "ed"));
                }
                case 723:
                    break;
                case 261:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 2; {
                        return (stem(2, "as", ""));
                    }
                case 724:
                    break;
                case 16: {
                    return (stem(3, "bite", "ed"));
                }
                case 725:
                    break;
                case 154: {
                    return (stem(3, "al", "ed"));
                }
                case 726:
                    break;
                case 213: {
                    return (stem(3, "", "s"));
                }
                case 727:
                    break;
                case 302:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 3; {
                        return (stem(3, "be", "ed"));
                    }
                case 728:
                    break;
                case 35: {
                    return (stem(3, "be", "ed"));
                }
                case 729:
                    break;
                case 32: {
                    return (stem(3, "sit", "ed"));
                }
                case 730:
                    break;
                case 240: {
                    return (stem(5, "each", "ed"));
                }
                case 731:
                    break;
                case 364: {
                    return (stem(9, "-a-terre", "s"));
                }
                case 732:
                    break;
                case 84: {
                    return (stem(3, "now", "ed"));
                }
                case 733:
                    break;
                case 22: {
                    return (stem(3, "gin", "en"));
                }
                case 734:
                    break;
                case 269: {
                    return (stem(3, "ie", "ed"));
                }
                case 735:
                    break;
                case 75: {
                    return (stem(3, "ee", "ed"));
                }
                case 736:
                    break;
                case 86: {
                    return (stem(3, "eep", "ed"));
                }
                case 737:
                    break;
                case 208:
                    // lookahead expression with fixed base length
                    zzMarkedPos = zzStartRead + 2; {
                        return (stem(2, "would", ""));
                    }
                case 738:
                    break;
                case 54: {
                    return (stem(3, "leed", "ed"));
                }
                case 739:
                    break;
                case 26: {
                    return (stem(3, "lead", "ed"));
                }
                case 740:
                    break;
                case 265: {
                    return (stem(7, "clepe", "ed"));
                }
                case 741:
                    break;
                case 319: {
                    return (stem(4, "eps", "s"));
                }
                case 742:
                    break;
                case 310: {
                    return (stem(5, "ify", "ed"));
                }
                case 743:
                    break;
                case 211: {
                    return (condub_stem(2, "ed"));
                }
                case 744:
                    break;
                default:
                    if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
                        zzAtEOF = true;
                        {
                            return null;
                        }
                    } else {
                        zzScanError(ZZ_NO_MATCH);
                    }
            }
        }
    }
}
